begin
  int[] a = [1,2,3];
  int[] b = [3,4];
  int[][] c = [a,b] ;
  println c[0][2] ;
  println c[1][0]
end


===========================================================
0	.data
1	.text
2	.global main
3	main:
4		push {fp, lr}
5		push {r4, r5, r6, r8, r10, r12}
6		mov fp, sp
7		@ Stack pointer unchanged, no stack allocated variables
8		@ 3 element array
9		mov r0, #16
10		bl malloc
11		mov r12, r0
12		@ array pointers are shifted forwards by 4 bytes (to account for size)
13		add r12, r12, #4
14		mov r8, #3
15		str r8, [r12, #-4]
16		mov r8, #1  @LOADING ARR 1
17		str r8, [r12, #0]
18		mov r8, #2
19		str r8, [r12, #4]
20		mov r8, #3
21		str r8, [r12, #8]
22		mov r8, r12
23		mov r4, r8
24		@ 2 element array
25		mov r0, #12
26		bl malloc
27		mov r12, r0
28		@ array pointers are shifted forwards by 4 bytes (to account for size)
29		add r12, r12, #4
30		mov r8, #2
31		str r8, [r12, #-4]
32		mov r8, #3  @LOADING ARR 2
33		str r8, [r12, #0]
34		mov r8, #4
35		str r8, [r12, #4]
36		mov r8, r12
37		mov r5, r8
38		@ 2 element array
39		mov r0, #12
40		bl malloc
41		mov r12, r0
42		@ array pointers are shifted forwards by 4 bytes (to account for size)
43		add r12, r12, #4
44		mov r8, #2
45		str r8, [r12, #-4]
46		mov r8, r4
47		str r8, [r12, #0]
48		mov r8, r5
49		str r8, [r12, #4]
50		mov r8, r12
51		mov r6, r8
52		mov r10, #0
53		mov r3, r6
54		bl _arrLoad
55		mov r8, r3
56		mov r8, r8
57		push {r8}
58		mov r10, #2
59		pop {r8}
60		mov r3, r8
61		bl _arrLoad
62		mov r8, r3
63		mov r8, r8
64		mov r0, r8
65		@ statement primitives do not return results (but will clobber r0/rax)
66		bl _printi
67		bl _println
68		mov r10, #1
69		mov r3, r6
70		bl _arrLoad
71		mov r8, r3
72		mov r8, r8
73		push {r8}
74		mov r10, #0
75		pop {r8}
76		mov r3, r8
77		bl _arrLoad
78		mov r8, r3
79		mov r8, r8
80		mov r0, r8
81		@ statement primitives do not return results (but will clobber r0/rax)
82		bl _printi
83		bl _println
84		@ Stack pointer unchanged, no stack allocated variables
85		mov r0, #0
86		pop {r4, r5, r6, r8, r10, r12}
87		pop {fp, pc}
88	
89	.data
90	@ length of .L._prints_str0
91		.word 4
92	.L._prints_str0:
93		.asciz "%.*s"
94	.text
95	_prints:
96		push {lr}
97		mov r2, r0
98		ldr r1, [r0, #-4]
99		ldr r0, =.L._prints_str0
100		bl printf
101		mov r0, #0
102		bl fflush
103		pop {pc}
104	
105	.data
106	@ length of .L._printi_str0
107		.word 2
108	.L._printi_str0:
109		.asciz "%d"
110	.text
111	_printi:
112		push {lr}
113		mov r1, r0
114		ldr r0, =.L._printi_str0
115		bl printf
116		mov r0, #0
117		bl fflush
118		pop {pc}
119	
120	.data
121	@ length of .L._println_str0
122		.word 0
123	.L._println_str0:
124		.asciz ""
125	.text
126	_println:
127		push {lr}
128		ldr r0, =.L._println_str0
129		bl puts
130		mov r0, #0
131		bl fflush
132		pop {pc}
133	
134	_arrLoad:
135		@ Special calling convention: array ptr passed in R3, index in R10, LR (R14) is used as general register, and return into R3
136		push {lr}
137		cmp r10, #0
138		movlt r1, r10
139		bllt _boundsCheck
140		ldr lr, [r3, #-4]
141		cmp r10, lr
142		movge r1, r10
143		blge _boundsCheck
144		ldr r3, [r3, r10, lsl #2]
145		pop {pc}
146	
147	.data
148	@ length of .L._boundsCheck_str0
149		.word 42
150	.L._boundsCheck_str0:
151		.asciz "fatal error: array index %d out of bounds\n"
152	.text
153	_boundsCheck:
154		ldr r0, =.L._boundsCheck_str0
155		bl printf
156		mov r0, #0
157		bl fflush
158		mov r0, #255
159		bl exit
===========================================================
-- Finished